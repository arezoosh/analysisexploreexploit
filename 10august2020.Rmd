---
title: "Calculations of decision making problem"
output:
  pdf_document: default
  html_document: default
fig_caption: yes
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```
## Bandit Task
This part simulates values of the bandit task using gittin's index. Each arm has its own gittin index. I built payout for arms and use them for simulation. 'explorebandit' keeps exploratory/exploitative of each round with binary (1/0) variables.
```{r}

totalround <- 20 # number of rounds
simsize <- 500 # number of simulation/participants
goodorbad <- 0.5
goodpercent <- 0.7
badpercent <- 0.3
#number of high numbers in arm B
totalhighB <- (goodorbad * totalround * goodpercent ) + ((1-goodorbad) * totalround * badpercent)
#number of low numbers in arm B
totallowB <- totalround- totalhighB
gittinA <- matrix(ncol = simsize)
gittinB <- matrix(ncol = simsize)
exploitnoA <- matrix(ncol = simsize)
exploitnoB <- matrix(ncol = simsize)
explorenoA <- matrix(ncol = simsize)
explorenoB <- matrix(ncol = simsize)
exploitA <- matrix(ncol = totalround,nrow=simsize)
exploitB <- matrix(ncol = totalround,nrow=simsize)
outbandit <- matrix(ncol = totalround,nrow=simsize)
explorebandit <- matrix(ncol = totalround,nrow=simsize) 
outA <- 7900 # payout of arm A-fixed arm
# build outcome for B
highB <- 15800 # highest payout of arm B
lowB <- 0 # lowest payout of arm B
cutpoint <- 0
```
One arm has a single type (A) while the other (B) has two types. Specifically, the fixed arm yields a payoff of `r outA` points if it is selected. The uncertain arm either yields a good or bad payoffs with the probability of $0.5$. The probability of the good type has a high payoff is set to $g = 0.7$. Consequently the probability of the bad type has a high payoff set to $n = 0.3$ similar to the banks1997's study. The values for the high payoff is `r highB` and the bad payoff is $0$.
```{r}
for (j in 1:simsize) 
  {
  #build good part of arm B's payout- 70% highest value,30% zero
goodB <- sample(c(lowB,highB),totalround/2,prob = c(0.3,0.7),replace = TRUE)
#build bad part of arm B's payout- 30% highest value,70% zero
badB <- sample(c(lowB,highB),totalround/2,prob = c(0.7,0.3),replace = TRUE)
#payout behind arm B
outB <- c(goodB,badB) 
i<-1
gittinB[j] <- 0
explorebandit[j,1] <- 0

  while(length(outB) > 0 && i < totalround +1) #loop over rounds
    {
      
      if (cutpoint > gittinB[j])
        {
          explorebandit[j,i] <- 0
          outbandit[j,i] <- outA
          i <- i+1
         }
      else if (cutpoint < gittinB[j])
        {
          explorebandit[j,i] <- 1
         outbandit[j,i] <- sample(outB,1)
         outB <- outB[-match(outbandit[j,i],outB)]
   # eliminate captured number
    #check seen number
  
          if (outbandit[j,i] == 0)
            {
              totallowB <- totallowB -1 
              gittinB[j] <- gittinB[j] - 1 
             } else {
               totalhighB <- totalhighB -1 
               gittinB[j] <- gittinB[j] + 1 
             }
          i <- i+1
        }
      else if (cutpoint == gittinB[j])
        {
         rndchoice <- sample(c(0,1),1)
         if (rndchoice==1){
            explorebandit[j,i] <- 1
            outbandit[j,i] <- sample(outB,1)
            outB <- outB[-match(outbandit[j,i],outB)]
            # eliminate captured number
           #check seen number
            if (outbandit[j,i] == 0)
               {
                totallowB <- totallowB - 1    #counter for total                   low numbers
                gittinB[j] <- gittinB[j] - 1  

                } else {
                totalhighB <- totalhighB -1   # counter for total                   high numbers
                gittinB[j] <- gittinB[j] + 1 
                }
          } else{
            explorebandit[j,i]  <- 0
             outbandit[j,i] <- outA

                }
          i <- i+1
        }
    }

}
#percentage of choosing armB over all
exprcntg1 <- (sum(explorebandit))/length(explorebandit)
hist(explorebandit,main = paste("Histogram of selection in bandit"),xlab = 'Selected arm', ylab='Frequency')
par(mar=c(1,1,1,1))
#plot(1:length(explorebandit),explorebandit,type="l")


```
 At first, gittin index of the arm B is equal to the cutpoint. Thus choosing one arm is random and it is labeled as exploration. If selected arm was B and resulted a higher outcome `r highB`, the gittin index of arm B is increased by $1$. But if the payoff of selecting this arm is $0$, the gittin index of arm B decreases by $1$. It doesn't affect arm A gittin's and if arm A was chosen randomly, its gittin index doesn't change (It is always constant).

This process of selection repeats for `r totalround` and agent choose the arm with the higher gittin's index and update this value based on the outcome. After selection of each value, the selected number is removed from total values and its related counter decreased. 
The total percentage of exploration in this task is `r exprcntg1`


## Visual Task

###variable definition and code description

This part simulates values of the visual task using function 'exploring'.
'expthigh' is expected value of the higher option
'selhigh' is the higher selected option
'numbers' is the number of remaining option that has not selected yet.
'count' measure time after each fixation
'totalhigh' has the number of higher values
'totallow' has the number of lower values
'tmpdt' hold available unseen options on the screen
'idtime' holds identification time which was 0.3 seconds based on the pilot data.
'fixedval' holds the value of the fixed option
'highvalue' keeps starting point of the higher range
'lowvalue' keeps starting point of lower range
'dctime' keeps the time that by reaching it one point decreases from fixed option
'totlval' has total number of options to keep track of captured ones.
'explr' keeps the exploratory or exploitative of a current choice



```{r}
exploring <- function(expthigh,selhigh,numbers,count,totalhigh,totallow,tmpdt,idtime,fixedval,highvalue,lowvalue,dctime,totalval,explorevisual) {
  probtmpsample <- totalhigh/(totalhigh+totallow)
  tmpsample <- selhigh
  assign('count',count + idtime)
  
  if (count >= dctime) {
    dd <- list('selhighest_sample'=selhigh,'probability'=probtmpsample,'expectation'=expthigh,'exploration'=explorevisual,'total_sample'=totalval - numbers +1)
    #assign('count',count + idtime)
    #return(dd)
    dd
    #break
  }
  else if (numbers > 0 && count < dctime && !explorevisual){
    if(totalhigh+totallow == 0){
      break
    }
    if (length(tmpdt)== 0) break
    tmpsample <- sample(tmpdt,size = 1) # capture a value
    indices <- which(tmpsample==tmpdt) # find captured number
    tmpdt <- tmpdt[-indices] # eliminate captured number
    #check seen number
    assign('numbers',numbers - 1)
    if ((tmpsample >= highvalue) && (totalhigh+totallow != 0)) 
      
    { # seen value comes from selhigher range
      probtmpsample <- totalhigh/(totalhigh+totallow)
      assign('totalhigh',totalhigh - 1)
      dh <- 1
      dl <- 0
    }
    else if ((tmpsample < highvalue) && (totalhigh+totallow != 0))
    {  # seen value comes from lower range
      probtmpsample <- totalhigh/(totalhigh+totallow)
      assign('totallow',totallow - 1)
      dh <- 0
      dl <- 1
    }
    
    if ((tmpsample * probtmpsample >= expthigh) && (probtmpsample != Inf))
    { # selhigher than previews expected value
      expthigh <- tmpsample * probtmpsample
      selhigh <- tmpsample 
      assign('explorevisual',1)
      dd <- list('selhighest_sample'=selhigh,'probability'=probtmpsample,'expectation'=expthigh,'exploration'=explorevisual,'total_sample'=totalval - numbers + 1)
      dd
      #break
    }
    else if ((tmpsample * probtmpsample < expthigh) && (probtmpsample != Inf))
    { # lower than previews expected value
      #  # finish if it's lower than previews selhigh
      assign('explorevisual',0)
      exploring(expthigh,selhigh,numbers,count,totalhigh,totallow,tmpdt,idtime,fixedval,highvalue,lowvalue,dctime,totalval,explorevisual)
    } 
  }
  
}
```


```{r}
# initialization of variables with different decreasing time
## 1- set decreasing time = 3
totalround <- 20 # number of rounds
simsize <- 1000 # number of simulation/participants
outdddd1 <-  array(list(), dim = c(simsize,totalround))


for (i in 1:simsize){
  for (j in 1:totalround){

total <- 132
highper <- 10/100
lowper <- 90/100
fixed <- sample(1350:1650,1)
#make high and low sequences
l <- 0
h <- 0
lowval <- 1001
highval <- 16601
rangeval <- 299

seqlow <- seq(lowval,lowval+rangeval)
seqhigh <- seq(highval,highval+rangeval)
samplehigh <- sample(seqhigh,size = round(total*highper), replace = FALSE)
samplelow <- sample(seqlow,size = round(total*lowper), replace = FALSE)
#visualdata has the values of the visual task
visualdata1 <- (c(samplehigh,samplelow))
#mixed values
visualdata <- sample(visualdata1)


tmpdata <- visualdata
n <- total
#""""""" important important important important
 # change this
  #plot on paper set with counter <-0.2 change it
#""""""""" important important important important
counter <- 0.3 # it starts from 0.3 because of the selection of fixed option at the begining.
totalhigh <- round(total*highper)
totallow <- round(total*lowper)
identification_time <- 0.3 # at least 0.1s is needed to identify a target\cite{kotowicz2010time}- in pilot average fixation is 0.3
dectime <- 3 # reducing point time in seconds
explr <- 0
outdddd1[[i]][[j]] <- exploring(fixed,fixed,n,counter,totalhigh,totallow,tmpdata,identification_time,fixed,highval,lowval,dectime,total,explr)
  }
}
#explorevisual1 <- matrix(ncol = totalround,nrow=simsize)
explorevisual1<-array(NA,dim = c(simsize,totalround))
proball<-array(NA,dim = c(simsize,totalround))
exptall<-array(NA,dim = c(simsize,totalround))
selecall<-array(NA,dim = c(simsize,totalround))
numberall<-array(NA,dim = c(simsize,totalround))
ex21 <- 0
for (i in 1:simsize)
{
  for (j in 1:totalround)
  {
    proball[i,j]<-outdddd1[[i]][[j]][["probability"]]
    exptall[i,j]<-outdddd1[[i]][[j]][["expectation"]]
    selecall[i,j]<-outdddd1[[i]][[j]][["selhighest_sample"]]
    numberall[i,j]<-outdddd1[[i]][[j]][["total_sample"]]
    explorevisual1[i,j] <- (outdddd1[[i]][[j]][["exploration"]])
    ex21 <- explorevisual1[i,j] + ex21 
  }
}
mydata<-data.frame('probability'=unmatrix(proball,byrow = TRUE),'expectation'=unmatrix(exptall,byrow = TRUE),'selection'=unmatrix(selecall,byrow = TRUE),'totalsample'=unmatrix(numberall,byrow = TRUE),'exploratory'=unmatrix(explorevisual1,byrow = TRUE))
plot(colMeans(proball),type = 'l',xlab = 'periods',ylab = 'probability',main = 'average probability for high value of 1000 agent')
sepprob<-array(NA,dim = 10)
sepexpt<-array(NA,dim = 10)
for (i in 1:10){
  sepprob[i]<-mean(mydata$probability[mydata$totalsample==i],na.rm=TRUE)
  sepexpt[i]<-mean(mydata$expectation[mydata$totalsample==i],na.rm=TRUE)
}
plot(sepprob,xlab = 'number of samples',ylab = 'average high value probabilities',main = 'average probability of 1000 agents',type = 'l')
plot(sepexpt,xlab = 'number of samples',ylab = 'average high value expectation',main = 'average expected value of 1000 agents',type = 'l')

exprcntg21 <- ex21 / (simsize*totalround)
par(mar=c(1,1,1,1))
hist(explorevisual1,main = paste("Histogram of selection in visual dectime=3"),xlab = 'Selected option', ylab='Frequency')
corres <- cor.test(explorevisual1,explorebandit)
```
At first the fixed value choose as the best option. Thus in the second movement, agents try to find the higher options by randomly choosing one option from whole. If this value is lower than the previews one, and agent's time is lower than the `r dectime` seconds, choosing behavior continues. On the other hand if this selected value is higher than the previews one, this new value replaces the old one as the new higher value and one trial searching process terminates and labeled as exploratory. But if agent is not lucky and couldn't find higher value than the fixed one before it reaches to the decreasing time, this agent chooses the fixed one and stop searching which labeled as exploitative. 'explorevisual' keeps agants choice. It is $0$ when the agent selects from fixed option and it is $1$ when agent selects from varied options. The size of this data structure is `r simsize` times `r totalround`.


to simulate task space options, the first step was to produce unique values that were needed to put on the task’s screen (`r total` random values, `r highper`% from higher [`r highval`,`r highval+rangeval`] and `r lowper`% from lower [`r lowval`,`r lowval+rangeval`] ranges).
The fixed value set to be lower than higher range and higher than lower range (`r fixed`). The lower range starts from `r lowval` for `r rangeval` numbers. The higher range starts from `r highval` for `r rangeval` numbers. seqlow matrix has the samples from the lower range values and seqhigh has the higher range values.

sampling have done for the required values. `r round(total*highper)` numbers from upper range and `r round(total*lowper)` numbers are sampled from lower range without replacement. Then data were concatenate and mixed and saved as visualdata for one round.

To make a sense of how many points a risk neutral decision maker will sample and how much the sampling gives in the end this part simulates decision-maker's behavior `r simsize` times. A decision-maker decides repeatedly whether to stop search or continue. 

It starts by choosing fixed value as the highest value (HIGH). Then it continues by searching options one by one to find one with the higher expected value than the previous one. By getting a draw from the lower interval, searching will continue until it gets close to the decreasing time. If until then a participant can't find a higher value, she return to the fixed option.
But if the seen value belongs to the higher interval, its expected value calculate using the number of higher interval divided by the number of total values. However, if the draw belongs to the lower interval its expectation calculates by the division of the number of lower interval values over total values. After each draw one decreases from the number of related low/high interval and also overall numbers. If the expected value of the found value is higher than the previous one, HIGH value is updated to the new one. If the draw does not belong to the upper bound, HIGH value remains unchanged. In both mentioned conditions searching continues. But when the value is chosen from the upper bound and is not higher than the previous HIGH value, searching is terminated.
The value of the fixed option decreases by $350$ points every `r dectime`. This ensures that the fixed option value is higher than the lower range at the beginning of each trial and then after passing `r dectime` it gets equal to values from the lower range. By passing this time, fixed value gets lower than the lower range and it is no longer optimal to choose. This setting forces decision maker to choose like a myopic decision maker. Choice of the fixed option is optimal before reaching to the to decreasing time. The value of `r dectime` is chosen because of having congruent exploration rate with the bandit that was equal to `r exprcntg1`. This is calculated using simulation.

```{r}

# initialization of variables with different decreasing time
## 1- set decreasing time = 1.5
totalround <- 20 # number of rounds
simsize <- 500 # number of simulation/participants
outdddd2 <-  array(list(), dim = c(simsize,totalround))


for (i in 1:simsize){
  for (j in 1:totalround){

total <- 133
highper <- 10/100
lowper <- 90/100
fixed <- sample(1350:1650,1)
#make high and low sequences
l <- 0
h <- 0
lowval <- 1001
highval <- 16501
rangeval <- 299

seqlow <- seq(lowval,lowval+rangeval)
seqhigh <- seq(highval,highval+rangeval)
samplehigh <- sample(seqhigh,size = round(total*highper), replace = FALSE)
samplelow <- sample(seqlow,size = round(total*lowper), replace = FALSE)
#visualdata has the values of the visual task
visualdata1 <- (c(samplehigh,samplelow))
#mixed values
visualdata <- sample(visualdata1)


tmpdata <- visualdata
n <- total
counter <- 0.3 # it starts from 0.3 because of the selection of fixed option at the begining.
totalhigh <- round(total*highper)
totallow <- round(total*lowper)
identification_time <- 0.3 # at least 0.1s is needed to identify a target \cite{kotowicz2010time}- in pilot average fixation is 0.3
dectime <- 1.5 # reducing point time in seconds
explr <- 0
outdddd2[[i]][[j]] <- exploring(fixed,fixed,n,counter,totalhigh,totallow,tmpdata,identification_time,fixed,highval,lowval,dectime,total,explr)
  }
}
explorevisual2 <- matrix(ncol = totalround,nrow=simsize)
ex22 <- 0
for (i in 1:simsize)
{
  for (j in 1:totalround)
  {
    explorevisual2[i,j] <- (outdddd2[[i]][[j]][["exploration"]])
    ex22 <- explorevisual2[i,j] + ex22 
  }
}
exprcntg22 <- ex22 / (simsize*totalround)
par(mar=c(1,1,1,1))
hist(explorevisual2,main = paste("Histogram of selection in visual dectime=1.5"),xlab = 'Selected option', ylab='Frequency')
corres <- cor.test(explorevisual2,explorebandit)







```

```{r}

# initialization of variables with different decreasing time
## 1- set decreasing time = 2
totalround <- 20 # number of rounds
simsize <- 500 # number of simulation/participants
outdddd3 <-  array(list(), dim = c(simsize,totalround))


for (i in 1:simsize){
  for (j in 1:totalround){
    
    total <- 133
    highper <- 10/100
    lowper <- 90/100
    fixed <- sample(1350:1650,1)
    #make high and low sequences
    l <- 0
    h <- 0
    lowval <- 1001
    highval <- 16501
    rangeval <- 299
    
    seqlow <- seq(lowval,lowval+rangeval)
    seqhigh <- seq(highval,highval+rangeval)
    samplehigh <- sample(seqhigh,size = round(total*highper), replace = FALSE)
    samplelow <- sample(seqlow,size = round(total*lowper), replace = FALSE)
    #visualdata has the values of the visual task
    visualdata1 <- (c(samplehigh,samplelow))
    #mixed values
    visualdata <- sample(visualdata1)
    
    
    tmpdata <- visualdata
    n <- total
    counter <- 0.3 # it starts from 0.3 because of the selection of fixed option at the begining.
    totalhigh <- round(total*highper)
    totallow <- round(total*lowper)
    identification_time <- 0.3 # at least 0.1s is needed to identify a target \cite{kotowicz2010time}- in pilot average fixation is 0.3
    dectime <- 2 # reducing point time in seconds
    explr <- 0
    outdddd3[[i]][[j]] <- exploring(fixed,fixed,n,counter,totalhigh,totallow,tmpdata,identification_time,fixed,highval,lowval,dectime,total,explr)
  }
}
explorevisual3 <- matrix(ncol = totalround,nrow=simsize)
ex23 <- 0
for (i in 1:simsize)
{
  for (j in 1:totalround)
  {
    explorevisual3[i,j] <- (outdddd3[[i]][[j]][["exploration"]])
    ex23 <- explorevisual3[i,j] + ex23 
  }
}
exprcntg23 <- ex23 / (simsize*totalround)
par(mar=c(1,1,1,1))
hist(explorevisual3,main = paste("Histogram of selection in visual dectime=2"),xlab = 'Selected option', ylab='Frequency')
corres <- cor.test(explorevisual3,explorebandit)


```
The total percentage of exploration in this task for different decreasing time of $1$, $1.5$ and $2$ are `r exprcntg21`, `r exprcntg22` and `r exprcntg23` respectively. 

## hypothesis and related analysis

It is hypothesized that higher exploration in the choice modality (first task) is correlated with higher exploration in the visual sampling modality (second task). While exploitation in the choice is correlated with higher exploitation in visual sampling. 
There are two ideas to check this hypothesis:

###First idea

1- calculate each person's exploration rate in the first task: (number of exploratory choice divided by total choice)
2- calculate each person's exploration rate in the second task: (sum of fixation duration in the exploratory surrounding part divided by total fixation)
3- convert these two values to z-score
4- find correlation
5- use risk taking question as a definitive of the behavior in regression 

###second idea

find out relation between two modalities in both tasks
1-  calculate each person's choice exploration rate in both tasks(number of exploratory choice divided by total choice)
2-  calculate each person's visual exploration rate in both tasks(sum of fixation duration in the exploratory part of both tasks)
3- convert these values to z-score
4- find correlation between and within tasks






